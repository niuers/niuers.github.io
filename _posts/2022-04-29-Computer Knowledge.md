---
title: "Computer Knowledge"
date: 2022-04-29
categories:
  - blog
tags:
  - summary
  - Computer Knowledge
---

1. Processes
    1. 内存空间被划分为了两块: 用户空间，内核空间。
        1. 用户空间: 用户空间装着用户进程需要使用的资源，比如你在程序代码里开一个数组，这个数组肯定存在用户空间
        2. 内核空间: 内核空间存放内核进程需要加载的系统资源，这一些资源一般是不允许用户访问的。但是注意有的用户进程会共享一些内核空间的资源，比如一些动态链接库等等。
    2. 你编译好的那个可执行程序只是一个文件，不是进程，可执行文件必须要载入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的
    3. 操作系统是如何创建进程的呢？
        1. 对于操作系统，进程就是一个数据结构
        2. `task_struct` 就是 `Linux` 内核对于一个进程的描述，也可以称为「进程描述符」。
            1. 其中比较有意思的是 `mm` 指针. `mm` 指向的是进程的虚拟内存，也就是载入资源和可执行文件的地方；
            2. `files` 指针指向一个数组，这个数组里装着所有该进程打开的文件的指针。一般来说，一个进程会从 `files[0]` 读取输入，将输出写入 `files[1]`，将错误信息写入 `files[2]`. 每个进程被创建时，`files` 的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。
    4. 在 Linux 系统中，进程和线程几乎没有区别. 因为从 Linux 内核的角度来看，并没有把线程和进程区别对待。
        1. 无论线程还是进程，都是用 `task_struct` 结构表示的，唯一的区别就是共享的数据区域不同。
        2. 线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享。就比如说，`mm` 结构和 `files` 结构在线程中都是共享的
        3. 所以说，我们的多线程程序要利用锁机制，避免多个线程同时往同一区域写入数据，否则可能造成数据错乱。
        4. 在 `Linux` 中新建线程和进程的效率都是很高的，对于新建进程时内存区域拷贝的问题，`Linux` 采用了 `copy-on-write` 的策略优化，也就是并不真正复制父进程的内存空间，而是等到需要写操作时才去复制。所以 `Linux` 中新建进程和新建线程都是很迅速的。


2. Threads

3. 文件描述符
    1. 不要忘了，Linux 中一切都被抽象成文件，设备也是文件，可以进行读和写。
    2. 
[LINUX 的进程/线程/文件描述符是什么]: https://labuladong.github.io/algo/5/34/


4. 关于 LINUX SHELL 你必须知道的
    1. 标准输入和参数的区别
        1. 标准输入就是编程语言中诸如scanf或者readline这种命令；而参数是指程序的main函数传入的args字符数组。
        2. 管道符和重定向符是将数据作为程序的标准输入，而`$(cmd)`是读取`cmd`命令输出的数据作为参数。
        3. 如果命令能够让终端阻塞，说明该命令接收标准输入，反之就是不接受，比如你只运行`cat`命令不加任何参数，终端就会阻塞，等待你输入字符串并回显相同的字符串。
            1. `rm` 命令源代码中肯定不接受标准输入，而是接收命令行参数，删除相应的文件。作为对比，`cat` 命令是既接受标准输入，又接受命令行参数


5. 后台运行程序
    1. 每一个命令行终端都是一个 `shell` 进程，你在这个终端里执行的程序实际上都是这个 `shell` 进程分出来的子进程。正常情况下，`shell` 进程会阻塞，等待子进程退出才重新接收你输入的新的命令。加上`&`号，只是让 `shell` 进程不再阻塞，可以继续响应你的新命令。但是无论如何，你如果关掉了这个 `shell` 命令行端口，依附于它的所有子进程都会退出。
    2. 而`(cmd &)`这样运行命令，则是将`cmd`命令挂到一个`systemd`系统守护进程名下，认`systemd`做爸爸，这样当你退出当前终端时，对于刚才的`cmd`命令就完全没有影响了。
    3. 类似的，还有一种后台运行常用的做法是这样：`$ nohup some_cmd &`. `nohub` 命令也是类似的原理，不过通过我的测试，还是`(cmd &)`这种形式更加稳定。

6. 单引号和双引号的区别
    1. 对于`$，(，)`这几个符号，单引号包围的字符串不会做任何转义，双引号包围的字符串会转义。也就是说，如果 `$` 读取出的参数字符串包含空格，应该用双引号括起来，否则就会出错。
    2. shell 的行为可以测试，使用set -x命令，会开启 shell 的命令回显，你可以通过回显观察 shell 到底在执行什么命令
        1. echo $(who)
        2. echo '$(who)'
        3. echo "$(who)"

7. sudo 找不到命令
    1. 当使用 sudo 时，系统会使用 /etc/sudoers 这个文件中规定的该用户的权限和环境变量
    2. 解决方法是使用脚本文件的路径，而不是仅仅通过脚本名称：`$ sudo /home/fdl/bin/connect.sh`

     





