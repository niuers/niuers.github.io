---
title: "Trees"
date: 2021-04-14
categories:
  - blog
tags:
  - algorithm
  - leetcode
  - traversal
  - DFS
  - BFS
  - summary
---

1. Traversal:
    1. When to use DFS and when to use BFS?
        1. BFS: Searching for **shortest path**
            * If using DFS, it can be a very wrong (LC909) when a later node can jump back to node in front of the current one.
    1. Depth-First-Search (DFS)
        1. recursion method
        1. preorder
        2. inorder
        3. postorder
        4. DFS and Union Find (LC721)
    2. Breadth-First-Search (BFS)
        1. Usually we keep a `visited` set to avoid repetive visiting of the same node
            * By the way, normally for BFS, the main space complexity lies in the process rather than the initialization. For instance, for a BFS traversal in a tree, at any given moment, the queue would hold no more than 2 levels of tree nodes. Therefore, the space complexity of BFS traversal in a tree would depend on the width of the input tree.
        2. BFS is usually used to find the shortest path
            * You can put the distance together with key into the deque
            * Keeping track of how many cells at each distance are on the queue
            * If you can overwrite the input, you can put the distance onto the original input
            * Starting a new collection for each distance as there are at most two unique distances in the queue at any one time.
            * `A*` algorithm (Advanced), see [Shortest Path in Binary Matrix][LC1091]: 
                * Intuition: At certain point, one of the two cells to explore seemed far more promising than the other. We want to modify the algorithm to prioritize promising paths over not so promising paths. To do this, we need to come up with a heuristic that, given a potential option, it measures how much "promise" that option has. Then we prioritize the options (exploring cells) with the highest "promise". In the previous approaches, we were actually doing this: our heuristic was simply distance traveled so far. But we can do better than that!
                * Instead, we're going to score them based on distance traveled so far plus our most optimistic estimate of how many more steps it would take to get to the destination cell from there. 
                * Problem: We have made the wrong assumption that we can take the most promising cell and assume that the best possible distance to all of its neighbors is 1 more. But this is not always the case. 
                * To solve this, we simply need to remove the bad assumption; we shouldn't conclude that the first path we discover into a cell is the best one. Instead, we should keep track of all the options and then choose the best one when we get to it.
                * Suppose an estimate of a cell represents the shortest possible path we could get from the top-left to the bottom-right if we were to go through that cell.
                * A "child" cell could never have a lower estimate () than a "parent" cell. If it did, this would mean that the "parent" cell's estimate was not the lowest possible; we would have just found a way for it to be lower, which is contradictory. So when a "parent" cell puts options to get to "child" cells onto the priority queue, the estimates for these options are never less than the estimate for the parent. If the parent's estimate is `x`, then it will only put options with estimates of `x` or higher onto the priority queue.
                * The key implication of this is that if there is a way to get to a cell that assigns it an estimate of x, then we know that we won't inadvertently accept a higher estimate, only to later discard the x estimate like our first attempt at this algorithm might have done. Estimates of x can only be put onto the queue by cells with an estimate of x or lower. So by definition, we know that once we're taking off options with an estimate of x + 1, we have already exhausted all possible ways of getting estimates of x. Each estimate value "tier" has all of its members identified before and during the processing of that "tier"
                * No cell can have an estimate lower than that of the top-left cell.
                * For A*, we are assigning the most optimistic possible estimate to each cell and then exploring cells in non-decreasing order of these estimates. We'll keep track of potential options into cells that we haven't yet visited using a priority queue. 
                * The key idea is that the estimates for any given path from the top-left to bottom-right cell are non-decreasing;
                * This is `O(NlogN)` complexity if we don't limit the size of priority queue. The `N` is the total number of cells.







            




        1. preorder
        2. inorder
        3. postorder
        Implementation: queue



    3. Recover Tree from different orders
        1. Recover Binary Search Tree            
            * [Serialize in preorder and deserialize using stack or recursive method using current value as lower/upper bound][LeetCode 449]
            * Serialize in postorder and deserialize recursively
        2. One can also serialize using BFS, like LeetCode does for the tree structure.
    4. Binary Search Tree
        1. FACT: Inorder traversal of BST is an array sorted in the ascending order: `inorder = sorted(preorder)`.
        2. FACT: BST could be constructed from preorder or postorder traversal only.

        5. How to handle duplicates



2. How did I or Other people get the solution? 

3. Different solutions


4. Mistakes

5. Problem Type
    
6. Similar Problems

7. Template

8. I understand the solution, but HOW do I think to GET there myself?
    1. Where could you improve?
        * I should've written the DFS cleaner. This might be a candidate for template.
    2. What questions should I ask myself so that I push myself closer to the solution? 
    3. What conclusions did I reach that I dropped some idea for the other?
        * For dynamic programming, I need find sub-optimal problems. But this doesn't work here.
    4. How can I reach this conclusion faster ?
    



Resources:
* [827. Making A Large Island][LeetCode Link]


[LeetCode Link]: https://leetcode.com/problems/making-a-large-island/
[LeetCode 449]: https://leetcode.com/problems/serialize-and-deserialize-bst/
[LC1091]: https://leetcode.com/problems/shortest-path-in-binary-matrix/solution/