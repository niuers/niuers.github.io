---
title: "Data Structure and Algorithms"
date: 2022-04-15
categories:
  - blog
tags:
  - algorithm
  - summary
---

1. 从整体到细节，自顶向下，从抽象到具体的框架思维是通用的，不只是学习数据结构和算法，学习其他任何知识都是高效的。

2. [学习算法和刷题的框架思维][学习算法和刷题的框架思维]
  1. 数据结构的存储方式
    * 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。
  2. 数据结构的基本操作
    * 对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。
    * 各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的
      * 线性就是 for/while 迭代为代表，
      * 非线性就是递归为代表
  3. 算法刷题指南
    * 先刷二叉树
      * 因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题。
    * 只要涉及递归的问题，都是树的问题
      * 其实很多动态规划问题就是在遍历一棵树，你如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别人解法的核心思路。
      * 回溯算法就是个 N 叉树的前后序遍历问题，没有例外。
  4. 算法的本质
    * 算法的本质就是「穷举」
    * 穷举有两个关键难点：无遗漏、无冗余
      * 如何穷举？即无遗漏地穷举所有可能解。
        * 什么算法的难点在「如何穷举」呢？一般是递归类问题，最典型的就是动态规划系列问题。
      * 如何聪明地穷举？即避免所有冗余的计算。
        * 什么算法的难点在「如何聪明地穷举」呢？一些耳熟能详的非递归算法技巧，都可以归在这一类
          * Union Find
          * Greedy
  5. 数组/单链表系列算法
    * 单链表常考的技巧就是双指针
    * 数组常用的技巧有很大一部分还是双指针相关的技巧，说白了是教你如何聪明地进行穷举
      * 二分搜索技巧: 可以归为两端向中心的双指针
      * 滑动窗口算法技巧，典型的快慢双指针，快慢指针中间就是滑动的「窗口」，主要用于解决子串问题
      * 前缀和技巧
      * 差分数组技巧
  6. 二叉树系列算法
    * 二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架
    * 更进一步，图论相关的算法也是二叉树算法的延续
  7. 正确的刷题方式应该是刷一道题能获得刷十道题的效果，不然力扣现在 2000 道题目，你都打算刷完么？
    * 要有框架思维，学会提炼重点，一个算法技巧可以包装出一百道题，如果你能一眼看穿它的本质，那就没必要浪费时间刷了嘛。

  
2. DFS 算法解题套路框架: 其实 DFS 算法就是回溯算法

3. BFS 算法解题套路框架
  1. BFS 相对 DFS 的最主要的区别是：BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多
  2. 问题的本质就是让你在一幅「图」中找到从起点 start 到终点 target 的最近距离，这个例子听起来很枯燥，但是 BFS 算法问题其实都是在干这个事儿
  3. Framework
  ```
  // 计算从起点 start 到终点 target 的最近距离
  int BFS(Node start, Node target) {
      Queue<Node> q; // 核心数据结构
      Set<Node> visited; // 避免走回头路, 大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited
      
      q.offer(start); // 将起点加入队列
      visited.add(start);
      int step = 0; // 记录扩散的步数

      while (q not empty) {
          int sz = q.size();
          /* 将当前队列中的所有节点向四周扩散 */
          for (int i = 0; i < sz; i++) {
              Node cur = q.poll();
              /* 划重点：这里判断是否到达终点 */
              if (cur is target)
                  return step;
              /* 将 cur 的相邻节点加入队列 */
              for (Node x : cur.adj()) {
                  if (x not in visited) {
                      q.offer(x);
                      visited.add(x);
                  }
              }
          }
          /* 划重点：更新步数在这里 */
          step++;
      }
  }
  ```

  4. 为什么 BFS 可以找到最短距离，DFS 不行吗？
    1. DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。
    2. 形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。
  5. 既然 BFS 那么好，为啥 DFS 还要存在？
    1. BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。
  6. 双向 BFS 优化
    1. 传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。
    2. 双向 BFS 是要比传统 BFS 高效的。不过，双向 BFS 也有局限，因为你必须知道终点在哪里。
    3. 双向 BFS 还是遵循 BFS 算法框架的，只是不再使用队列，而是使用 HashSet 方便快速判断两个集合是否有交集。
    4. 另外的一个技巧点就是 while 循环的最后交换 q1 和 q2 的内容，所以只要默认扩散 q1 就相当于轮流扩散 q1 和 q2。
    5. 其实双向 BFS 还有一个优化，就是在 while 循环开始时做一个判断：如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。

5. Big O 表示法
    1. `O(g(n)) = { f(n): 存在正常量 c 和 n_0，使得对所有 n ≥ n_0，有 0 ≤ f(n) ≤ c*g(n) }`
    2. 只保留增长速率最快的项，其他的项可以省略。
    3. 





[学习算法和刷题的框架思维]: https://labuladong.github.io/algo/1/2/
[BFS 算法解题套路框架]: https://labuladong.github.io/algo/1/6/

    





