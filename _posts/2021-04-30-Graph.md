---
title: "Graph"
date: 2021-04-30
categories:
  - blog
tags:
  - algorithm
  - graph
  - summary
---

1. Definitions and Implementations:
    1. A graph is connected if there is a path from every vertex to every other vertex in the graph.
    2. Acyclic graph: a graph with no cycles.
    3. A Tree: is an acyclic connected graph.
    4. Spanning Tree: A spanning tree of a graph is a connected subgraph with no cycles that include all vertices.
    5. For simple graph (at most one edge between any pair of vertices), the asympotic relationship between `V` and `E` is: `E=O(V^2)`, the upper bound is achieved in a complete graph.
    6. Adjacency-lists (linked list) data structure to represent the edges for vertex

2. Directed Graph (Digraph)
    1. Reverse a digraph
    2. Multiple-source reachability. Given a digraph and a set of source vertices, support queries of the form "Is there a directed path from any vertex in the set to a given target vertex v?" (Mark-and-sweep garbage collection)
        * DFS
    3. Scheduling problems: Precedence-constrained scheduling (Topological sort)
        * Given a digraph, put the vertices in order such that all its directed edges point from a vertex earlier in the order to a vertex later in the order (or report that doing so is not possible)
        * It is based on the idea that depth-first search visits each vertex exactly once. If we save the vertex given as argument to the recursive `dfs()` in a data structure, then iterate through that data structure, we see all the graph vertices, in order determined by the nature of the data structure and by whether we do the save before or after the recursive calls. Three vertex orderings are of interest in typical applications:
            * Preorder: Put the vertex on a queue before the recursive calls
            * Postorder : Put the vertex on a queue after the recursive calls
            * Reverse postorder (Topologic sort) : Put the vertex on a stack after the recursive calls (`V+E`)
    4. Cycles in digraphs (Directed cycle detection)
        * Does a given digraph have a directed cycle? If so, find the vertices on some such cycle, in order from some vertex back to itself. i.e. Is it a DAG? 
        * A directed acyclic graph (DAG) is a digraph with no directed cycles.
        * DFS: It uses a boolean array onStack[] to keep track of the vertices for which the recursive call has not completed. When it finds an edge v->w to a vertex w that is on the stack, it has discovered a directed cycle, which it can recover by following edgeTo[] links.

2. Depth-First Search (DFS)
    1. Recursive:
        * Complexity: DFS marks all the vertices connected to a given source in time proportional to the sume of their degrees (`2E`). 
            * To run DFS on all vertices of a graph (so we need visit each vertex once at least), the complexity is `V+E`.
        * We encounter each edge in the graph twice (once at each of its vertices)
        * Careful not to repeat vertices
        * Uses LIFO stack
    2. Single-source connectivity: Are two given vertices connected (path detection) ? and How many connected components does the graph have ?
        * DFS: `V+E`
        * Union-Find: however it can't find the path
            * It's an online algorithm: we can check whether two vertices are connected in near-constant time at any point, even while adding edges
    3. Single-source paths (Finding Paths). Given a graph and a source vertex s, support queries of the form "Is there a path from s to a given target vertex v? If so, find such a path".
        * DFS
            * It maintains a vertex-indexed array `edgeTo[]` or `parent[]` such that `edgeTo[w] = v` means that `v-w` was the edge used to access `w` for the first time. The `edgeTo[]` array is a parent-link representation of a tree rooted at `s` that contains all the vertices connected to `s`. Instead of just keeping track of the path from the current vertex back to the start
            * The paths discovered by depth-first search depend not just on the graph, but also on the representation and the nature of the recursion.    
    4. Two-colorability: Can the vertices of a given graph be assigned one of two colors in such a way that no edge connects vertices of the same color ? which is equivalent to this question: Is the graph bipartite ?
    5. Edge Classification
        * Tree edges: (parent pointer in DFS), the edges that are used in DFS to visit new vertex. They form a tree (and forest).
        * Forward edges
        * Backward edges: if a vertex is already on the stack, then current edge is back edge
        * Cross edges
        * In an undirected graph, only tree edges and backward edges can exist. There are no forward/cross edges.
    6. Cycle detection        
        * A graph `G` has a cycle if and only if the depth-first search of `G` has a back edge.
    7. Topological Sort
        * It usually applies on a DAG, so there's no back edge (no cycle). 
        * Run DFS output reverse of finishing times (the time after we finished processing all of its adjcent vertices) of vertices

3. Breadth-First-Search (BFS)
    1. The goal is to visit all the nodes reachable from a given node 's'
        1. Uses FIFO queue
        2. BFS takes time proportional to `V+E` in the worst case. You only check each edge once (`|E|` in directed graph) or twice (`2|E|` in undirected graph), and a vertex enters the queue only once. 
        3. Need to be carful to avoid duplicates
    2. **Single-source shortest paths**. Given a graph and a source vertex `s`, support queries of the form "Is there a path from s to a given target vertex v? If so, find a shortest such path (one with a minimal number of edges, not necessarily the only one)"
        * BFS: It also maintains `edgeTo[]` or `parent[]` to save the paths
    3. Dijkstraâ€™s algorithm solves the **single-source shortest-paths problem in edge-weighted digraphs with nonnegative weights**.
        * All-pairs shortest paths. Given an edge-weighted digraph, support queries of the form Given a source vertex s and a target vertex t, is there a path from s to t? If so, find a shortest such path (one whose total weight is minimal).

4. Minimum Spanning Tree (MST) of Edge-Weighted Undirected Graph
    0. A minimum spanning tree (MST ) of an edge-weighted graph is a spanning tree whose weight (the sum of the weights of its edges) is no larger than the weight of any other spanning tree.
    1. Adding an edge that connects two vertices in a tree creates a unique cycle
    2. Removing an edge from a tree breaks it into two separate subtrees
    3. Cut Property: A cut of a graph is a partition of its vertices into two nonempty disjoint sets. A crossing edge of a cut is an edge that connects a vertex in one set with a vertex in the other.
        * Given any cut in an edge-weighted graph, the crossing edge of minimum weight is in the MST of the graph.
        * Note that there is no requirement that the minimal edge be the only MST edge connect- ing the two sets; indeed, for typical cuts there are several MST edges that connect a vertex in one set with a vertex in the other
    4. The edge weights are all different. If edges can have equal weights, the minimum spanning tree may not be unique.
    5. Greedy Algorithm
        1. The following method colors black all edges in the the MST of any connected edge-weighted graph with V vertices: starting with all edges colored gray, find a cut with no black edges, color its minimum-weight edge black, and continue until V?1 edges have been colored black.
        2. Prim's Algorithm
            1. Use priority queue to hold crossing edges and find the cut with minimum weight
            2. We can use eager algorithm, we maintain on the priority queue just one edge for each non-tree vertex w: the shortest edge that connects it to the tree.
            2. Time complexity: `ElogE` (lazy version), `E log V` (eager version)
        3. Kruskal's Algorithm
            1. It processes the edges in order of their weight values (smallest to largest), taking for the MST (coloring black) each edge that does not form a cycle with edges previously added, stopping after adding V-1 edges have been taken.
            2. It use a priority queue to consider the edges in order by weight, a **union-find** data structure to identify those that cause cycles, and a queue to collect the MST edges.
            3. Space: `E`, Time: `ElogE`

6. The shortest path with minimum total weights from a source
    1. Example: [The Maze II ][LC505 The Maze II]
    2. Optimal Substructure
        * Subpaths of a shortest path are shortest paths
    3. Algorithms
        * Dijkstra Algorithm
        * Bellmen-Ford Algorithm
            * Works on edge with both positive and negative weights
            * `O(VE)`
            * Negative weight cycle: need detect and mark the related vertices with infinity cost
        * General Structure of the shortest path problem (no negative cycles)
            * Initialize: set source distance `d[s]=0`, and for each vertice `u`, set distance `d[u]`(The length of the current shortest path from `u` to source `s`) to `infinity`, and predecessor `p[u]` (The predecessor of `u` in the shortest path from `s` to `u`) as `None`
            * Repeat: select some edge `(u,v)` in some way (Algorithm specific)
            * **"Relax"** `edge(u,v)`: 
            ```
            if d[v] > d[u] + w(u,v)
                d[v] = d[u] + w(u,v)
                p[v] = u #predecessor
            ```
            * Until all edges have `d[v] <= d[u] + w(u,v)` (brutal force)
            * This algorithm depends on the ordering of vertices we choose which can be exponentially time complexity
    4. Dijkstra Algorithm
        * It assumes nonnegative weights  
        * It works with graph with cycles
        * Complexity: `O(VlogV +E)`, practically linear time, mostly dominated by `E`. 
            * Note, the complexity doesn't depend on the dynamic range of the weights at all.
            * BFS and DFS aren't directly applicable to the shortest path problem for graph with weights because of the dynamic weights.
            * Operations in Dijkstra
                * `O(V)`: insertion into priority queue (ADT)
                    * array: `O(V)`
                    * min-heap: `O(logV)`
                * `O(V)`: extract-min from priority queue 
                    * array: `O(V)`
                    * min-heap: `O(logV)` extract min
                * `O(E)`: relax (decrease key) operation on each vertex            
                    * array: `O(1)`
                    * min-heap: `O(logV)` for relaxation
                * Total complexity:
                    * Array: `O(V^2+E)=O(V^2)`
                    * Heap: `O(VlogV + ElogV)` (Fibonacci heap can remove the logV in second term)
        * Need keep the predecessors leading up to current vertex
        * This is an example of greedy algorithm

    5. The Shortest Path Algorithm for DAG
        * **Whenenver you have DAG, try topological sort the DAG**, path from `u` to `v` implies that `u` is before `v` in ordering.
            * You can start from any vertex
        * One pass (left to right) over the vertices in topologically sorted order,  relax each edge that leaves each vertex
        * `O(V+E)`
        * This works with negative weights, but not with negative cycle
        * This is an example of dynamic programming.



[LeetCode Link]: https://leetcode.com/problems/making-a-large-island/
[LC505 The Maze II]: https://leetcode.com/problems/the-maze-ii/